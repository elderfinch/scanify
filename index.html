<!DOCTYPE html>
<html lang="en" data-theme="light">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scanify</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/remixicon@4.3.0/fonts/remixicon.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsfeat/0.0.8/jsfeat-min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/glfx@0.0.4/glfx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/localforage@1.10.0/dist/localforage.min.js"></script>
    <style>
      body { min-height: 100vh; }
      #mainCanvas { max-width: 100%; max-height: 100%; width: auto; height: auto; display: block; touch-action: none; }
      .loupe { position: fixed; width: 120px; height: 120px; border-radius: 9999px; border: 4px solid #fff; overflow: hidden; pointer-events: none; z-index: 60; box-shadow: 0 12px 30px rgba(0,0,0,.35); }
      .loupe::before,.loupe::after { content:''; position:absolute; background:rgba(255,255,255,.7); }
      .loupe::before { width: 2px; height: 100%; left: 50%; transform: translateX(-50%); }
      .loupe::after { height: 2px; width: 100%; top: 50%; transform: translateY(-50%); }
      .thumb.active { outline: 2px solid hsl(var(--p)); }
    </style>
  </head>
  <body class="bg-base-200">
    <div id="loading" class="fixed inset-0 z-[100] flex items-center justify-center bg-base-300/90 backdrop-blur">
      <div class="text-center"><span class="loading loading-spinner loading-lg"></span><p class="font-semibold mt-3">Initializing Scan Engine...</p></div>
    </div>

    <div class="h-screen flex flex-col">
      <header class="navbar bg-base-100 shadow-sm">
        <div class="flex-1 px-2"><span class="text-2xl font-bold">Scanify</span></div>
        <div class="flex-none gap-2 pr-2">
          <button id="newScanBtn" class="btn btn-sm btn-error btn-outline"><i class="ri-delete-bin-line"></i>New Scan</button>
          <button id="settingsBtn" class="btn btn-sm btn-ghost"><i class="ri-settings-3-line"></i></button>
        </div>
      </header>

      <main class="flex-1 p-3 overflow-hidden">
        <div class="h-full flex flex-col md:flex-row gap-3">
          <aside class="md:w-1/5 w-full bg-base-100 rounded-xl p-3 shadow flex flex-col overflow-hidden">
            <input id="fileInput" type="file" accept="image/*" capture="environment" class="hidden" />
            <button id="uploadBtn" class="btn btn-sm btn-primary"><i class="ri-camera-line"></i>Upload / Camera</button>
            <div class="divider my-2">Pages</div>
            <div id="filmstrip" class="flex-1 space-y-2 overflow-y-auto pr-1"></div>
            <button id="addPageBtn" class="btn btn-sm btn-accent mt-2"><i class="ri-add-circle-line"></i>Add Page</button>
          </aside>

          <section class="md:w-4/5 w-full bg-base-300 rounded-xl p-3 shadow flex flex-col overflow-hidden relative">
            <div class="flex flex-wrap items-center gap-2 mb-2">
              <button id="scanBtn" class="btn btn-sm btn-secondary"><i class="ri-crop-line"></i>Scan</button>
              <button id="downloadPdfBtn" class="btn btn-sm btn-primary"><i class="ri-file-pdf-line"></i>Download PDF</button>
              <div class="join">
                <input class="join-item btn btn-sm" type="radio" name="filterMode" value="original" aria-label="Original" checked />
                <input class="join-item btn btn-sm" type="radio" name="filterMode" value="better" aria-label="Better" />
                <input class="join-item btn btn-sm" type="radio" name="filterMode" value="magic" aria-label="Magic" />
                <input class="join-item btn btn-sm" type="radio" name="filterMode" value="bw" aria-label="B&W" />
              </div>
              <span id="stageBadge" class="badge badge-outline">Crop Stage</span>
              <span id="status" class="text-xs opacity-70">Load an image to begin.</span>
            </div>

            <div id="canvasWrap" class="flex-1 bg-base-200 rounded-lg overflow-auto flex items-center justify-center">
              <canvas id="mainCanvas"></canvas>
            </div>

            <div class="absolute right-5 bottom-5 flex flex-col gap-2">
              <button id="zoomInBtn" class="btn btn-circle btn-sm"><i class="ri-zoom-in-line"></i></button>
              <button id="zoomOutBtn" class="btn btn-circle btn-sm"><i class="ri-zoom-out-line"></i></button>
              <button id="rotateBtn" class="btn btn-circle btn-sm"><i class="ri-refresh-line"></i></button>
            </div>
          </section>
        </div>
      </main>
    </div>

    <div id="loupe" class="loupe hidden"><canvas id="loupeCanvas" width="120" height="120"></canvas></div>

    <dialog id="settingsModal" class="modal">
      <div class="modal-box">
        <h3 class="font-bold text-lg mb-3">Settings</h3>
        <div class="space-y-3">
          <label class="form-control">
            <span class="label-text">Theme</span>
            <select id="themeSelect" class="select select-bordered">
              <option>light</option><option>dark</option><option>cupcake</option><option>bumblebee</option><option>emerald</option><option>corporate</option><option>synthwave</option><option>retro</option><option>cyberpunk</option><option>valentine</option><option>halloween</option><option>garden</option><option>forest</option><option>aqua</option><option>lofi</option><option>pastel</option><option>fantasy</option><option>wireframe</option><option>black</option><option>luxury</option><option>dracula</option>
            </select>
          </label>
          <label class="form-control">
            <span class="label-text">Language</span>
            <select id="languageSelect" class="select select-bordered">
              <option value="en">English</option>
              <option value="es">Spanish</option>
              <option value="fr">French</option>
            </select>
          </label>
          <label class="form-control">
            <span class="label-text">PDF Size</span>
            <select id="pdfSizeSelect" class="select select-bordered">
              <option value="a4">A4</option>
              <option value="letter">Letter</option>
            </select>
          </label>
        </div>
        <div class="modal-action"><form method="dialog"><button class="btn">Close</button></form></div>
      </div>
    </dialog>

    <script>
      const DB_KEY = 'scanify-state-v3';
      const state = {
        ready: false,
        stage: 'crop',
        zoom: 1,
        imageSrc: null,
        sourceCanvas: document.createElement('canvas'),
        corners: [],
        draggingIndex: -1,
        activeFilter: 'magic',
        rendered: { original: null, better: null, magic: null, bw: null },
        pages: [],
        activePageId: null,
        settings: { theme: 'light', language: 'en', pdfSize: 'a4' },
      };

      const $ = (id) => document.getElementById(id);
      const refs = {
        canvas: $('mainCanvas'), loupe: $('loupe'), loupeCanvas: $('loupeCanvas'), status: $('status'),
        filmstrip: $('filmstrip'), fileInput: $('fileInput'), loading: $('loading'), stageBadge: $('stageBadge')
      };
      const ctx = refs.canvas.getContext('2d');
      const loupeCtx = refs.loupeCanvas.getContext('2d');

      function setStatus(t) {
        refs.status.textContent = t;
        console.info('[Scanify] status:', t);
      }
      function setStage(s) {
        state.stage = s;
        refs.stageBadge.textContent = s === 'crop' ? 'Crop Stage' : 'Review / Export';
      }
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

      function saveState() {
        console.debug('[Scanify] saving state');
        const payload = {
          stage: state.stage,
          zoom: state.zoom,
          imageSrc: state.imageSrc,
          corners: state.corners,
          activeFilter: state.activeFilter,
          pages: state.pages,
          activePageId: state.activePageId,
          settings: state.settings,
        };
        return localforage.setItem(DB_KEY, payload);
      }

      async function restoreState() {
        console.debug('[Scanify] restoring state');
        const data = await localforage.getItem(DB_KEY);
        if (!data) {
          console.debug('[Scanify] no saved state found');
          return;
        }
        Object.assign(state, data);
        applySettingsUI();
        renderFilmstrip();
        if (state.imageSrc) {
          const img = await dataUrlToImage(state.imageSrc);
          drawSource(img);
          if (state.stage === 'review' && state.pages.length) {
            const page = state.pages.find((p) => p.id === state.activePageId) || state.pages[state.pages.length - 1];
            if (page) {
              const im = await dataUrlToImage(page.outputs[state.activeFilter] || page.outputs.magic);
              drawImageFit(im);
            }
          }
        }
        document.querySelector(`input[name="filterMode"][value="${state.activeFilter}"]`)?.setAttribute('checked', 'checked');
        setStage(state.stage);
      }

      function applySettingsUI() {
        document.documentElement.setAttribute('data-theme', state.settings.theme);
        $('themeSelect').value = state.settings.theme;
        $('languageSelect').value = state.settings.language;
        $('pdfSizeSelect').value = state.settings.pdfSize;
      }

      async function clearAll() {
        console.warn('[Scanify] clearing storage');
        await localforage.removeItem(DB_KEY);
        location.reload();
      }

      function dataUrlToImage(dataUrl) {
        return new Promise((resolve) => { const img = new Image(); img.onload = () => resolve(img); img.src = dataUrl; });
      }

      function drawImageFit(img) {
        refs.canvas.width = img.width;
        refs.canvas.height = img.height;
        ctx.clearRect(0, 0, refs.canvas.width, refs.canvas.height);
        ctx.drawImage(img, 0, 0);
      }

      function drawSource(img) {
        state.sourceCanvas.width = img.width;
        state.sourceCanvas.height = img.height;
        state.sourceCanvas.getContext('2d').drawImage(img, 0, 0);
        refs.canvas.width = img.width;
        refs.canvas.height = img.height;
        if (!state.corners.length) state.corners = autoDetectCornersDiagonal(state.sourceCanvas);
        drawCropOverlay();
      }

      function autoDetectCornersDiagonal(inputCanvas) {
        const maxW = 600;
        const ratio = Math.min(maxW / inputCanvas.width, 1);
        const w = Math.max(1, Math.round(inputCanvas.width * ratio));
        const h = Math.max(1, Math.round(inputCanvas.height * ratio));
        const small = document.createElement('canvas');
        small.width = w; small.height = h;
        const sctx = small.getContext('2d', { willReadFrequently: true });
        sctx.drawImage(inputCanvas, 0, 0, w, h);
        const rgba = sctx.getImageData(0,0,w,h);
        const gray = new jsfeat.matrix_t(w, h, jsfeat.U8_t | jsfeat.C1_t);
        jsfeat.imgproc.grayscale(rgba.data, w, h, gray, jsfeat.COLOR_RGBA2GRAY);
        jsfeat.imgproc.gaussian_blur(gray, gray, 5, 0);
        jsfeat.imgproc.canny(gray, gray, 50, 100);

        const edge = gray.data;
        const hasEdge = (x, y) => x >= 0 && y >= 0 && x < w && y < h && edge[y * w + x] > 0;

        function diagonalFrom(corner) {
          const dirs = { tl:[1,1], tr:[-1,1], br:[-1,-1], bl:[1,-1] };
          const starts = { tl:[0,0], tr:[w-1,0], br:[w-1,h-1], bl:[0,h-1] };
          const [sx, sy] = starts[corner];
          const [dx, dy] = dirs[corner];
          const maxT = Math.max(w, h);
          for (let t = 0; t < maxT; t++) {
            const x = sx + dx * t;
            const y = sy + dy * t;
            if (hasEdge(x,y)) return { x, y };
          }
          return null;
        }

        const points = [diagonalFrom('tl'), diagonalFrom('tr'), diagonalFrom('br'), diagonalFrom('bl')];
        const fallback = [ {x:20,y:20}, {x:w-20,y:20}, {x:w-20,y:h-20}, {x:20,y:h-20} ];
        const selected = points.every(Boolean) ? points : fallback;
        return sortTLTRBRBL(selected.map((p)=>({x:p.x/ratio,y:p.y/ratio})));
      }

      function sortTLTRBRBL(points) {
        const cx = points.reduce((a,p)=>a+p.x,0)/4;
        const cy = points.reduce((a,p)=>a+p.y,0)/4;
        const sorted = [...points].sort((a,b)=>Math.atan2(a.y-cy,a.x-cx)-Math.atan2(b.y-cy,b.x-cx));
        let start = 0;
        let minSum = Infinity;
        sorted.forEach((p,i)=>{ const s = p.x+p.y; if (s < minSum) { minSum = s; start = i; } });
        const cyc = [0,1,2,3].map((k)=>sorted[(start+k)%4]);
        return cyc;
      }

      function drawCropOverlay() {
        refs.canvas.width = state.sourceCanvas.width;
        refs.canvas.height = state.sourceCanvas.height;
        ctx.clearRect(0,0,refs.canvas.width,refs.canvas.height);
        ctx.drawImage(state.sourceCanvas,0,0);
        const c = state.corners;
        if (c.length !== 4) return;
        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 3;
        ctx.beginPath(); c.forEach((p,i)=> i?ctx.lineTo(p.x,p.y):ctx.moveTo(p.x,p.y)); ctx.closePath(); ctx.stroke();
        ['#ef4444','#3b82f6','#22c55e','#f59e0b'].forEach((col,i)=>{
          const p = c[i]; ctx.fillStyle = col; ctx.beginPath(); ctx.arc(p.x,p.y,10,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
        });
      }

      function eventToCanvasPoint(ev) {
        const rect = refs.canvas.getBoundingClientRect();
        const p = ev.touches ? ev.touches[0] : ev;
        return {
          x: (p.clientX - rect.left) * refs.canvas.width / rect.width,
          y: (p.clientY - rect.top) * refs.canvas.height / rect.height,
          cx: p.clientX, cy: p.clientY,
        };
      }

      function showLoupe(px, py, x, y) {
        refs.loupe.classList.remove('hidden');
        refs.loupe.style.left = `${px - 60}px`;
        refs.loupe.style.top = `${py - 140}px`;
        loupeCtx.clearRect(0,0,120,120);
        const s = 48;
        loupeCtx.imageSmoothingEnabled = false;
        loupeCtx.drawImage(refs.canvas, x - s/2, y - s/2, s, s, 0,0,120,120);
      }

      function hideLoupe() { refs.loupe.classList.add('hidden'); }

      function pointerDown(ev) {
        if (state.stage !== 'crop') return;
        ev.preventDefault();
        const p = eventToCanvasPoint(ev);
        state.draggingIndex = state.corners.findIndex((c)=>dist(c,p)<24);
        if (state.draggingIndex >= 0) showLoupe(p.cx,p.cy,p.x,p.y);
      }
      function pointerMove(ev) {
        if (state.draggingIndex < 0 || state.stage !== 'crop') return;
        ev.preventDefault();
        const p = eventToCanvasPoint(ev);
        state.corners[state.draggingIndex].x = clamp(p.x, 0, refs.canvas.width);
        state.corners[state.draggingIndex].y = clamp(p.y, 0, refs.canvas.height);
        drawCropOverlay(); showLoupe(p.cx,p.cy,p.x,p.y);
      }
      async function pointerUp() { if (state.draggingIndex >= 0) await saveState(); state.draggingIndex=-1; hideLoupe(); }

      function warpPerspectiveGL(sourceCanvas, corners) {
        const [tl,tr,br,bl] = sortTLTRBRBL(corners);
        const w = Math.max(1, Math.round(Math.max(dist(br,bl), dist(tr,tl))));
        const h = Math.max(1, Math.round(Math.max(dist(tr,br), dist(tl,bl))));
        const fxCanvas = fx.canvas();
        fxCanvas.width = w; fxCanvas.height = h;
        const texture = fxCanvas.texture(sourceCanvas);
        fxCanvas.draw(texture).perspective([tl.x,tl.y,tr.x,tr.y,br.x,br.y,bl.x,bl.y],[0,0,w,0,w,h,0,h]).update();
        const out = document.createElement('canvas'); out.width = w; out.height = h;
        out.getContext('2d').drawImage(fxCanvas,0,0); texture.destroy();
        return out;
      }

      function grayscaleCanvas(c) {
        const o = document.createElement('canvas'); o.width=c.width; o.height=c.height;
        const x=o.getContext('2d',{willReadFrequently:true}); x.drawImage(c,0,0);
        const img=x.getImageData(0,0,o.width,o.height),d=img.data;
        for(let i=0;i<d.length;i+=4){const g=Math.round(0.299*d[i]+0.587*d[i+1]+0.114*d[i+2]); d[i]=d[i+1]=d[i+2]=g;}
        x.putImageData(img,0,0); return o;
      }
      function invertCanvas(c){const o=document.createElement('canvas');o.width=c.width;o.height=c.height;const x=o.getContext('2d',{willReadFrequently:true});x.drawImage(c,0,0);const img=x.getImageData(0,0,o.width,o.height),d=img.data;for(let i=0;i<d.length;i+=4){d[i]=255-d[i];d[i+1]=255-d[i+1];d[i+2]=255-d[i+2];}x.putImageData(img,0,0);return o;}
      function blurCanvas(c,r=20){const o=document.createElement('canvas');o.width=c.width;o.height=c.height;const x=o.getContext('2d');x.filter=`blur(${r}px)`;x.drawImage(c,0,0);x.filter='none';return o;}
      function gammaCanvas(c,g=1.2){const o=document.createElement('canvas');o.width=c.width;o.height=c.height;const x=o.getContext('2d',{willReadFrequently:true});x.drawImage(c,0,0);const img=x.getImageData(0,0,o.width,o.height),d=img.data;for(let i=0;i<d.length;i+=4){d[i]=255*Math.pow(d[i]/255,g);d[i+1]=255*Math.pow(d[i+1]/255,g);d[i+2]=255*Math.pow(d[i+2]/255,g);}x.putImageData(img,0,0);return o;}

      function magicFilter(colorCanvas) {
        const gray = grayscaleCanvas(colorCanvas);
        const inv = invertCanvas(gray);
        const mask = blurCanvas(inv, 20);
        const out = document.createElement('canvas'); out.width=colorCanvas.width; out.height=colorCanvas.height;
        const x = out.getContext('2d');
        x.globalCompositeOperation = 'source-over'; x.drawImage(colorCanvas,0,0);
        x.globalCompositeOperation = 'color-dodge'; x.drawImage(mask,0,0);
        x.globalCompositeOperation = 'source-over';
        return out;
      }

      function betterFilter(colorCanvas) {
        const out = document.createElement('canvas'); out.width=colorCanvas.width; out.height=colorCanvas.height;
        const x = out.getContext('2d', {willReadFrequently:true}); x.drawImage(colorCanvas,0,0);
        const blurred = document.createElement('canvas'); blurred.width=out.width; blurred.height=out.height;
        const bx = blurred.getContext('2d'); bx.filter = 'blur(2px)'; bx.drawImage(out,0,0); bx.filter='none';
        const base = x.getImageData(0,0,out.width,out.height), b = bx.getImageData(0,0,out.width,out.height);
        for (let i=0;i<base.data.length;i+=4) {
          for (let k=0;k<3;k++) {
            let v = base.data[i+k] + 0.6*(base.data[i+k]-b.data[i+k]);
            v = (v - 128) * 1.08 + 128;
            base.data[i+k] = clamp(v,0,255);
          }
        }
        x.putImageData(base,0,0); return out;
      }

      function bwFilter(colorCanvas) {
        const magic = magicFilter(colorCanvas);
        const gray = grayscaleCanvas(magic);
        return gammaCanvas(gray, 1.2);
      }

      async function scanNow() {
        if (!state.imageSrc) return setStatus('Upload an image first.');
        setStatus('Processing...');
        const warped = warpPerspectiveGL(state.sourceCanvas, state.corners);
        const better = betterFilter(warped);
        const magic = magicFilter(warped);
        const bw = bwFilter(warped);

        const outputs = {
          original: warped.toDataURL('image/png'),
          better: better.toDataURL('image/png'),
          magic: magic.toDataURL('image/png'),
          bw: bw.toDataURL('image/png'),
        };

        const id = state.pages.length ? Math.max(...state.pages.map((p)=>p.id))+1 : 1;
        const page = {
          id,
          originalSrc: state.imageSrc,
          corners: JSON.parse(JSON.stringify(sortTLTRBRBL(state.corners))),
          selectedFilter: 'magic',
          outputs,
          width: warped.width,
          height: warped.height,
        };
        state.pages.push(page);
        state.activePageId = id;
        state.activeFilter = 'magic';
        setStage('review');
        document.querySelector('input[name="filterMode"][value="magic"]').checked = true;
        renderFilmstrip();

        const img = await dataUrlToImage(outputs.magic);
        drawImageFit(img);
        setStatus('Scanned. Review and download PDF.');
        await saveState();
      }

      function renderFilmstrip() {
        refs.filmstrip.innerHTML = '';
        state.pages.forEach((p) => {
          const btn = document.createElement('button');
          btn.className = `thumb ${p.id===state.activePageId?'active':''} w-full text-left bg-base-200 rounded-lg p-1`;
          btn.innerHTML = `<img class="w-full h-24 object-cover rounded" src="${p.outputs[p.selectedFilter] || p.outputs.magic}" alt="Page ${p.id}" /><div class="text-xs mt-1 px-1">Page ${p.id} â€¢ ${p.selectedFilter}</div>`;
          btn.onclick = async () => {
            state.activePageId = p.id;
            setStage('review');
            const img = await dataUrlToImage(p.outputs[state.activeFilter] || p.outputs[p.selectedFilter] || p.outputs.magic);
            drawImageFit(img);
            renderFilmstrip();
            await saveState();
          };
          refs.filmstrip.appendChild(btn);
        });
      }

      async function openNewInput() { refs.fileInput.value=''; refs.fileInput.click(); }

      async function onInputFile(file) {
        if (!file) return;
        console.info('[Scanify] input file selected', { name: file.name, type: file.type, size: file.size });
        const fr = new FileReader();
        fr.onload = async () => {
          console.info('[Scanify] file loaded into memory');
          state.imageSrc = fr.result;
          state.corners = [];
          const img = await dataUrlToImage(state.imageSrc);
          setStage('crop');
          drawSource(img);
          setStatus('Adjust corners, then click Scan.');
          await saveState();
        };
        fr.readAsDataURL(file);
      }

      async function refreshReviewPreview() {
        const page = state.pages.find((p)=>p.id===state.activePageId);
        if (!page) return;
        page.selectedFilter = state.activeFilter;
        const src = page.outputs[state.activeFilter] || page.outputs.magic;
        const img = await dataUrlToImage(src);
        drawImageFit(img);
        renderFilmstrip();
        await saveState();
      }

      async function downloadPdf() {
        if (!state.pages.length) return setStatus('No pages to export yet.');
        const { jsPDF } = window.jspdf;
        const format = state.settings.pdfSize;
        const pdf = new jsPDF({ orientation: 'p', unit: 'mm', format });
        const pageSize = format === 'letter' ? { w: 216, h: 279 } : { w: 210, h: 297 };
        const margin = 10, maxW = pageSize.w - margin*2, maxH = pageSize.h - margin*2;
        state.pages.forEach((p, i) => {
          if (i) pdf.addPage(format, 'p');
          const src = p.outputs[p.selectedFilter] || p.outputs.magic;
          const ratio = Math.min(maxW / p.width, maxH / p.height);
          const w = p.width * ratio, h = p.height * ratio;
          const x = (pageSize.w - w)/2, y = (pageSize.h - h)/2;
          pdf.addImage(src, 'PNG', x, y, w, h);
        });
        pdf.save('scanify-document.pdf');
      }

      function rotateSource90() {
        if (!state.imageSrc || state.stage !== 'crop') return;
        const src = state.sourceCanvas;
        const c = document.createElement('canvas'); c.width = src.height; c.height = src.width;
        const x = c.getContext('2d'); x.translate(c.width/2,c.height/2); x.rotate(Math.PI/2); x.drawImage(src,-src.width/2,-src.height/2);
        state.sourceCanvas.width = c.width; state.sourceCanvas.height = c.height;
        state.sourceCanvas.getContext('2d').drawImage(c,0,0);
        state.imageSrc = c.toDataURL('image/png');
        state.corners = autoDetectCornersDiagonal(state.sourceCanvas);
        drawCropOverlay(); saveState();
      }

      function applyZoom() {
        refs.canvas.style.transformOrigin = 'center center';
        refs.canvas.style.transform = `scale(${state.zoom})`;
      }

      function bindEvents() {
        $('uploadBtn').onclick = openNewInput;
        $('addPageBtn').onclick = openNewInput;
        refs.fileInput.addEventListener('change', (e)=>onInputFile(e.target.files?.[0]));
        $('scanBtn').onclick = scanNow;
        $('downloadPdfBtn').onclick = downloadPdf;
        $('newScanBtn').onclick = clearAll;
        $('settingsBtn').onclick = ()=>$('settingsModal').showModal();

        $('themeSelect').addEventListener('change', async (e)=>{ state.settings.theme=e.target.value; applySettingsUI(); await saveState(); });
        $('languageSelect').addEventListener('change', async (e)=>{ state.settings.language=e.target.value; await saveState(); });
        $('pdfSizeSelect').addEventListener('change', async (e)=>{ state.settings.pdfSize=e.target.value; await saveState(); });

        document.querySelectorAll('input[name="filterMode"]').forEach((r)=>r.addEventListener('change', async (e)=>{ state.activeFilter=e.target.value; await refreshReviewPreview(); }));

        refs.canvas.addEventListener('mousedown', pointerDown);
        refs.canvas.addEventListener('mousemove', pointerMove);
        window.addEventListener('mouseup', pointerUp);
        refs.canvas.addEventListener('touchstart', pointerDown, { passive: false });
        refs.canvas.addEventListener('touchmove', pointerMove, { passive: false });
        window.addEventListener('touchend', pointerUp);
        window.addEventListener('touchcancel', pointerUp);

        $('zoomInBtn').onclick = async ()=>{ state.zoom = clamp(state.zoom + 0.2, 0.6, 3); applyZoom(); await saveState(); };
        $('zoomOutBtn').onclick = async ()=>{ state.zoom = clamp(state.zoom - 0.2, 0.6, 3); applyZoom(); await saveState(); };
        $('rotateBtn').onclick = rotateSource90;
      }

      async function init() {
        console.info('[Scanify] init start');
        bindEvents();
        if (!window.jsfeat || !window.fx || !window.jspdf || !window.localforage) {
          console.error('[Scanify] library check failed', {
            jsfeat: !!window.jsfeat,
            fx: !!window.fx,
            jspdf: !!window.jspdf,
            localforage: !!window.localforage,
          });
          setStatus('Failed to load required libraries.');
          refs.loading.classList.add('hidden');
          return;
        }
        console.info('[Scanify] libraries loaded');
        await restoreState();
        applySettingsUI();
        applyZoom();
        state.ready = true;
        refs.loading.classList.add('hidden');
        if (!state.pages.length && !state.imageSrc) setStatus('Engine ready. Upload or capture a document.');
        console.info('[Scanify] init complete', { stage: state.stage, pages: state.pages.length });
      }

      window.addEventListener('load', init);
      window.addEventListener('error', (event) => {
        console.error('[Scanify] window error', event.error || event.message);
        setStatus('Initialization error. Check console logs.');
        refs.loading.classList.add('hidden');
      });
      window.addEventListener('unhandledrejection', (event) => {
        console.error('[Scanify] unhandled rejection', event.reason);
        setStatus('Initialization error. Check console logs.');
        refs.loading.classList.add('hidden');
      });
    </script>
  </body>
</html>
